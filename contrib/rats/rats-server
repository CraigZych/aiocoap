#!/usr/bin/env python3

"""REST all the state

This is a draft for an application server all of whose state is available in a
RESTful manner. More precisely, the applicaton instances that are running on it
are stored as a link-header document. Applications themselves are often
stateless, but can create arbitrary resources that may store state.

Applications get no direct means to communicate with the outside world, but
they can be configured to have their resources bound to other resources in
either direction."""

import abc
from collections import namedtuple
import inspect
from pathlib import Path
from typing import Dict, Tuple
import json

import aiocoap.interfaces, aiocoap.message
import aiohttp
import aiohttp.web
# for demo only
import asyncio
import aiocoap, aiocoap.resource, aiocoap.util.cli

class _Typemap(namedtuple('__Typemap', [
    'contentformat_to_type',
    'type_to_contentformat',
    'default_contentformat',
    ])):
    """A translator between content-typed resources (whose payloads are always
    bytes) and native Python types."""

def _raise_as_valueerror(f, accepted_types=(KeyError, )):
    """Wrapper around a function that converts raised exception of
    accepted_types into `ValueError`s."""
    def wrapped(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except accepted_types:
            raise ValueError
    return wrapped

_plainencode = lambda x: str(x).encode('utf8')
# this might be too strict because it won't accept 40 (only 40.0) for a float
# which is not covered by json numeric types
def _decode_json(type):
    def _decoder(x):
        decoded = json.loads(x.decode('utf8'))
        if not isinstance(decoded, type):
            raise ValueError("JSON type does not fit")
        return decoded
    return _decoder
_encode_json = lambda x: json.dumps(x).encode('utf8')
default_typemap = _Typemap(
        contentformat_to_type={
            (0, int): int,
            (0, float): float,
            (0, str): lambda x: x.decode('utf8'),
            (0, bool): _raise_as_valueerror(lambda x: {0: False, 1: True}[int(x)]),
            (50, int): _decode_json(int),
            (50, float): _decode_json(float),
            (50, str): _decode_json(str),
            (50, bool): _decode_json(bool),
        },
        type_to_contentformat={
            (0, int): _plainencode,
            (0, float): _plainencode,
            (0, str): _plainencode,
            (0, bool): lambda x: str(int(x)).encode('utf8'),
            (50, int): _encode_json,
            (50, float): _encode_json,
            (50, str): _encode_json,
            (50, bool): _encode_json,
        },
        default_contentformat={
            int: 0,
            float: 0,
            str: 0,
            bool: 0,
        }
        )

class NativeResource:
    typehint = None

    @abc.abstractmethod
    async def get_native(self):
        """Get a resource's representation and parse/interpret it as the
        resource's type according to a typemap if it's not already implemented
        as a native resource. Raises a ValueError if the format is not
        understood, or possibly raises something else (?)."""
        raise NotImplementedError

    async def put_native(self, value):
        """Change the state of a resource to a given value. It is not
        necessaril checked against the typehint, but if the resource is not
        implemented as a native resource, wrong types might not make it through
        the typemap.

        This is not declared as an abstract method so non-writable resources
        can just not implement this."""

        raise NotImplementedError # more of a "Writing not possible"

class HTTPResource:
    @abc.abstractmethod
    async def handle_aiohttp(self, request):
        """Implementation of the resource for aiohttp. As aiohttp deals in
        handler functions and not instances, we get to choose its name; going
        for handle_aiohttp to avoid any conflicts."""

        raise NotImplementedError

CoAPResource = aiocoap.interfaces.Resource
# at some point in time this shoudl probably be replaced by to-be-developed
# new-style resources. i imagine them as having just a single render function
# (rather than the awkward render+needs_blockwise_assembly thing); the function
# could be an asynchronous function or an asynchronous generator
#
# open questions: can both be used by the same call style or do nonobservables
# need to always "async yield result; return"? can the single interface be
# easily used from outside, or should we just accept that there's one
# "implementation name" and one or more "invocation names" provided by the
# interface class? how do we flag resources that want blockwise handling not
# done from the outside? how can resources that do want blockwise handling done
# still slowly chunk out their data (both to quickly get first block responses,
# and to avoid keeping a whole file in memory)?

class FullResource(NativeResource, CoAPResource, HTTPResource):
    pass

class CoAPFromHTTP:
    """Mixin that implements a CH proxy"""
    async def needs_blockwise_assembly(self, request):
        return True

    async def render(self, request):
        raise NotImplementedError("TBD: Use self.context to build a response")

class HTTPFromCoAP:
    """Mixin that implements an HC proxy"""
    async def handle_aiohttp(self, request):
        if request.method != 'GET':
            raise NotImplementedError

        # FIXME this is a terrible cross proxy!

        request = aiocoap.Message(code=aiocoap.GET)
        response = await self.render(request)

        return aiohttp.web.Response(body=response.payload, headers={'Content-Type': 'text/plain'})

class CoAPFromNative(CoAPResource):
    """Mixin that implements answering CoAP requests from a native resource"""

    async def needs_blockwise_assembly(self, request):
        return True

    async def render(self, request):
        if request.code == aiocoap.GET:
            try:
                cf = request.opt.accept
                if cf is None:
                    cf = self.typemap.default_contentformat[self.typehint]
                mapper = self.typemap.type_to_contentformat[(cf, self.typehint)]
            except KeyError:
                raise aiocoap.error.NotAcceptable

            value = await self.get_native()
            return aiocoap.Message(payload=mapper(value))
        elif request.code == aiocoap.PUT:
            try:
                cf = request.opt.content_format
                if cf is None:
                    cf = self.typemap.default_contentformat[self.typehint]
                mapper = self.typemap.contentformat_to_type[(cf, self.typehint)]
            except KeyError:
                raise aiocoap.error.UnsupportedContentFormat

            try:
                value = mapper(request.payload)
            except ValueError:
                raise aiocoap.error.BadRequest

            await self.put_native(value)

            return aiocoap.Message(code=aiocoap.CHANGED)
        else:
            raise aiocoap.error.MethodNotAllowed()

class NativeFromCoAP(NativeResource):
    """Mixin that implements get_native/put_native() on a CoAP resource"""

    def __init__(self, typehint):
        self.typehint = typehint

    async def get_native(self):
        request = aiocoap.Message(
                code=aiocoap.GET,
                accept=self.typemap.default_contentformat.get(self.typehint, None),
                )
        response = await self.render(request)
        if response.code != aiocoap.CONTENT:
            # FIXME: could try without accept header
            raise RuntimeError("Request did not succeed")

        cf = request.opt.content_format
        try:
            if cf is None:
                cf = self.typemap.default_contentformat[self.typehint]
            mapper = self.typemap.contentformat_to_type[(cf, self.typehint)]
        except KeyError:
            raise ValueError("Conversion not supported")

        return mapper(response.payload)

    async def put_native(self, value):
        cf = self.typemap.default_contentformat.get(self.typehint)
        payload = self.typemap.type_to_contentformat[(cf, self.typehint)]

        request = aiocoap.Message(
                code=aiocoap.PUT,
                content_format=cf,
                payload=payload,
                )
        response = await self.render(request)
        if response.code != aiocoap.CHANGED:
            # FIXME could try with other content formats etc
            raise RuntimeError("Request did not succeed")

class RemoteCoAPResource(aiocoap.resource.Resource):
    def __init__(self, uri, context):
        self.uri = uri
        self.context = context

    # implementing aiocoap.Resource

    async def needs_blockwise_assembly(self, request):
        return True

    async def render(self, request):
        # FIXME: The protocol code should really ignore all mtype/mid/token
        # data or take them purely as hints; resetting all here like
        # aiocoap.proxy.server does.
        request = request.copy(
                mtype=None,
                mid=None,
                token=None,
                remote=None,
                uri=self.uri,
                )
        return (await self.context.request(request).response).copy(mid=None, token=None, mtype=None)

class FullRemoteCoAPResource(HTTPFromCoAP, RemoteCoAPResource, NativeFromCoAP, FullResource):
    typemap = default_typemap

    def __init__(self, uri, context, typehint):
        RemoteCoAPResource.__init__(self, uri, context)
        NativeFromCoAP.__init__(self, typehint)

class RemoteHTTPResource(HTTPResource):
    def __init__(self, uri, clientsession):
        self.uri = uri
        self.clientsession = clientsession

    # implementing HTTPResource

    async def handle_aiohttp(self, request):
        if 'Upgrade' in request.headers:
            raise NotImplementedError("Don't know how to handle an Upgrade request")
        @aiohttp.streamer
        async def forwarder(writer):
            while True:
                read = await request.content.read(1024)
                if not read:
                    return
                await writer.write(read)

        # FIXME this is still a very bad proxy on so many fronts -- host name, encoding, dunno what else
        request.headers['Host'] = 'christian.amsuess.com'

        async with self.clientsession.request(request.method, self.uri, headers=request.headers, data=forwarder) as resp:
            # FIXME stream this as we stream request data
            raw = await resp.read()

            # it was already decoded by aiohttp -- just another FIXME to do this right
            headers = dict(resp.headers)
            del headers['Content-Encoding']
            del headers['Content-Length']

            return aiohttp.web.Response(body=raw, status=resp.status, headers=headers)

class FullRemoteHTTPResource(RemoteHTTPResource, CoAPFromHTTP, FullResource):
    typemap = default_typemap

class NativeMemoryResource(NativeResource):
    typemap = default_typemap

    def __init__(self, initial_value, typehint=None):
        self._value = initial_value
        if typehint is None:
            self.typehint = type(self._value)
        else:
            self.typehint = typehint

    # implementing NativeResource

    async def get_native(self):
        return self._value

    async def put_native(self, data):
        # FIXME trigger observations when implemented
        self._value = data

class FullNativeMemoryResource(NativeMemoryResource, HTTPFromCoAP, CoAPFromNative, FullResource):
    pass

class ProxyResource(FullResource):
    """This resource is a proxy in the sense of object-oriented programming --
    it will forward (resource-related) calls to another resource set in its
    .forward property.

    In CoAP or HTTP terminology, this is equivalent to a reverse proxy."""

    def __init__(self, typehint_constraint=None):
        self.forward = None
        self.typehint_constraint = typehint_constraint # currently not enforced

    async def handle_aiohttp(self, request):
        return await self.forward.handle_aiohttp(request)

    async def needs_blockwise_assembly(self, request):
        return await self.forward.needs_blockwise_assembly(request)
    async def render(self, request):
        return await self.forward.render(request)

    typehint = property(lambda self: self.forward.typehint)
    async def get_native(self):
        return await self.forward.get_native()

# the above is infrastructure; here start actual rats

def load_python(file: Path) -> Dict[str, FullResource]:
    code = file.open().read()

    result = {}

    class DynamicNativeResource(HTTPFromCoAP, CoAPFromNative, FullResource):
        typemap = default_typemap

        def __init__(self, get_value, typehint):
            self._get_value = get_value
            self.typehint = typehint

        async def get_native(self):
            return await self._get_value()

    def register_method(name, signature, function):
        if result:
            raise Exception("Can't deal with multiple functions in one rat")
        for k, v in signature.parameters.items():
            if v.annotation is inspect._empty:
                raise ValueError("Refusing to register without type annotation on %s"%(k,)) # would fail later anyway
            result[k] = ProxyResource(typehint_constraint=v.annotation) # will be populated with a NativeResource if not lazily bound, otherwise with the bound resource
        async def get_value():
            args = []
            for k, v in signature.parameters.items():
                args.append(await result[k].get_native())
            return function(*args)
        # we don't need to worry about overwriting any argument name here:
        # that'd "just" make the ProxyResource inaccessible to everything, and
        # thus fail on every occasion.
        result[name] = DynamicNativeResource(get_value, signature.return_annotation)

    # FIXME this should obviously go into a separate process and use pypy
    # isolation
    class Rats:
        @staticmethod
        def pure(f):
            # this would need to pass from the inside to the outside of the isolation
            register_method(f.__name__, inspect.signature(f), f)

    module = exec(code, {'rats': Rats()})
    return result

def register_rats(rats, path: Tuple[str, ...], site: aiocoap.resource.Site, router: aiohttp.web_urldispatcher.UrlDispatcher):
    """Register the result of load_python both at a CoAP site and an HTTP server at a given path."""

    for key, res in rats.items():
        site.add_resource(path + (key,), res)

# infrastructure demo again

class Demo(aiocoap.util.cli.AsyncCLIDaemon):
    async def start(self):
        loop = asyncio.get_event_loop()

        site = aiocoap.resource.Site()

        self.http_clientcontext = aiohttp.ClientSession()
        clientcontext = await self.http_clientcontext.__aenter__()

        self.coapcontext = await aiocoap.Context.create_server_context(site=site)

        self.http_app = aiohttp.web.Application()

        # links and exports

        personalwebsite = FullRemoteHTTPResource('http://christian.amsuess.com/', clientcontext)
        coapme = FullRemoteCoAPResource('coap://coap.me/hello', self.coapcontext, str)

        site.add_resource(('personalwebsite',), personalwebsite)
        self.http_app.router.add_get('/personalwebsite', personalwebsite.handle_aiohttp)

        site.add_resource(('coapme',), coapme)
        self.http_app.router.add_route('*', '/coapme', coapme.handle_aiohttp)

        # actual rats demo

        adder = load_python(Path(__file__).parent / 'rats-adder.py')
        register_rats(adder, ('adder', ), site, self.http_app.router)

        for key, res in adder.items():
            if isinstance(res, ProxyResource):
                # wire up static None-initialized resources for the demo
                res.forward = FullNativeMemoryResource(None, res.typehint_constraint)

        rot13 = load_python(Path(__file__).parent / 'rats-rot13.py')
        register_rats(rot13, ('rot13', ), site, self.http_app.router)

        rot13['original'].forward = coapme

        # needs to be last, because app router gets frozen

        self.http_handler = self.http_app.make_handler()
        self.http_srv = await loop.create_server(self.http_handler, '0.0.0.0', 8080)

    async def shutdown(self):
        # see http://aiohttp.readthedocs.io/en/stable/web.html#aiohttp-web-graceful-shutdown
        await self.http_srv.wait_closed()
        await self.http_app.shutdown()
        await self.http_handler.shutdown(5)
        await self.http_app.cleanup()

        await self.coapcontext.shutdown()
        await self.http_clientcontext.__aexit__()

if __name__ == "__main__":
    Demo.sync_main()
